{
    "type": "bundle",
    "id": "bundle--adf3327c-f799-4009-85e9-f1b1e2fe0d15",
    "objects": [
        {
            "type": "vulnerability",
            "spec_version": "2.1",
            "id": "vulnerability--50ee9a97-0fd8-48f5-8e2f-3df1de5f2d76",
            "created_by_ref": "identity--8ce3f695-d5a4-4dc8-9e93-a65af453a31a",
            "created": "2024-07-16T01:02:57.976342Z",
            "modified": "2024-07-16T01:02:57.976342Z",
            "name": "CVE-2024-40935",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncachefiles: flush all requests after setting CACHEFILES_DEAD\n\nIn ondemand mode, when the daemon is processing an open request, if the\nkernel flags the cache as CACHEFILES_DEAD, the cachefiles_daemon_write()\nwill always return -EIO, so the daemon can't pass the copen to the kernel.\nThen the kernel process that is waiting for the copen triggers a hung_task.\n\nSince the DEAD state is irreversible, it can only be exited by closing\n/dev/cachefiles. Therefore, after calling cachefiles_io_error() to mark\nthe cache as CACHEFILES_DEAD, if in ondemand mode, flush all requests to\navoid the above hungtask. We may still be able to read some of the cached\ndata before closing the fd of /dev/cachefiles.\n\nNote that this relies on the patch that adds reference counting to the req,\notherwise it may UAF.",
            "external_references": [
                {
                    "source_name": "cve",
                    "external_id": "CVE-2024-40935"
                }
            ]
        }
    ]
}